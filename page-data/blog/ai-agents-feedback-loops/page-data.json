{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/ai-agents-feedback-loops/","result":{"data":{"site":{"siteMetadata":{"author":{"name":"Johnathan Gilday"},"blogTitle":"/ gilday / blog"}},"markdownRemark":{"id":"26f4b9cd-4c51-5d60-88a6-7b7b1653fc0a","excerpt":"Something shifted in my development workflow last month. I’m no longer writing code directly—instead, I’m orchestrating up to three AI coding agents working in…","html":"<p>Something shifted in my development workflow last month. <strong>I’m no longer writing code directly—instead, I’m orchestrating up to three AI coding agents working in parallel.</strong> It’s like going from playing a solo instrument to conducting a small orchestra. The less micro-managing each agent needs, the more I can accomplish simultaneously. (I’m eyeing a future where I can reliably manage 4+ agents, but that’s a story for another post.)</p>\n<p>This transformation got me thinking about feedback loops—those fundamental mechanisms that have quietly driven every major advancement in software development. As it turns out, <strong>they’ve never been more critical than they are right now with AI agents.</strong></p>\n<h2>The Evergreen Nature of Feedback Loops</h2>\n<p>If you trace the lineage of breakthrough developments in our field, you’ll find feedback loops at the heart of each one:</p>\n<p><strong>The Agile movement</strong> didn’t revolutionize software development because of stand-up meetings or sprint planning. It succeeded because it optimized for faster customer feedback by shipping in smaller iterations. <strong>The entire philosophy boils down to: <em>get feedback sooner</em>.</strong></p>\n<p><strong>Typed programming languages</strong> give developers immediate feedback on program correctness. That red squiggly line under your code? That’s a feedback loop preventing a runtime error hours or days later.</p>\n<p><strong>Extreme Programming (XP)</strong>, particularly its emphasis on unit testing, emerged to give developers rapid feedback on whether their changes work correctly. Behavior-Driven Development (BDD) extended this to ensure we’re building the right thing, not just building the thing right.</p>\n<p><strong>Modern deployment practices</strong>—observability, blue-green deployments, feature flags, testing in production—all exist to get high-fidelity feedback quickly from real production environments. <strong>CI/CD pipelines? Just automated feedback loops on steroids.</strong></p>\n<h2>The Speed Hierarchy</h2>\n<p>Not all feedback loops are created equal. <strong>Speed matters:</strong></p>\n<ul>\n<li>A fast compiler beats a slow compiler</li>\n<li>An interpreter that catches errors at parse time beats one that waits until runtime</li>\n<li>Linters and type checks beat unit tests</li>\n<li>Unit tests beat slow integration tests</li>\n<li>Integration tests beat manual QA</li>\n<li>Manual QA beats user bug reports</li>\n</ul>\n<p>The pattern is clear: <strong>faster feedback means faster iteration, which means faster delivery of working software.</strong></p>\n<h2>How Developers Know They’re Done</h2>\n<p>Good developers have always had strategies for knowing when their work is complete:</p>\n<ul>\n<li>Some practice TDD or BDD, letting tests define “done”</li>\n<li>Others rely on comprehensive observability to measure effectiveness in production</li>\n<li>The best combine multiple approaches, creating layered feedback mechanisms</li>\n</ul>\n<p>What they don’t do is YOLO changes into production and wait for users to report bugs. <strong>Making users your error detection system isn’t a strategy—it’s an abdication of responsibility.</strong></p>\n<h2>Enter AI Coding Agents</h2>\n<p>Here’s where things get interesting. Today’s AI models are mind-blowing in their capabilities, but they still make tons of basic mistakes. <strong>Their superpower isn’t perfection—it’s the <em>speed</em> at which they can make and correct those mistakes.</strong></p>\n<p>Give an AI agent a solid feedback loop that tells it when it’s done, and it will eventually solve the problem. It might take more iterations than a human developer, but it completes those iterations in seconds, not hours.</p>\n<p>A typical AI agent coding session looks like this:</p>\n<pre class=\"grvsc-container solarized-light grvsc-mm-t6zo1R\" data-language=\"\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">*generates code* → &quot;Oops, doesn&#39;t compile&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*regenerates* → &quot;Still doesn&#39;t compile&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*tries again* → &quot;Now it breaks these tests&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*iterates* → &quot;Different tests failing&quot;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">...</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*finally* → &quot;All tests passing! Done!&quot;</span></span></code></pre>\n<p><strong>This is the key insight</strong>: Your development cycles with AI agents are dominated by the latency of your feedback loops. <strong>The agent’s mistakes don’t matter nearly as much as how quickly it can detect and correct them.</strong></p>\n<h2>The Challenge of AI Confidence</h2>\n<p>AI agents have an interesting quirk—<strong>they often think they’re done before they actually are.</strong> I’ve lost count of the times an agent has confidently declared “The implementation is complete!” only to have the tests reveal multiple gaps in the requirements.</p>\n<p>This means you need to be explicit and stern about what constitutes “done.” <strong>Tell them exactly which tests to run, what output to expect, and how to verify their work is complete.</strong> Think of it as programming the programmer.</p>\n<h2>Enabling Low-Touch Agents</h2>\n<p>Automating the ability to verify that code meets the <em>definition of done</em> is paramount for running what I call “low-touch” agents—agents that can work asynchronously without constant supervision. <strong>This is what enables managing multiple agents in parallel.</strong></p>\n<p>If you don’t yet have a test that tells the AI agent when its job is done, <strong>creating that test should be the agent’s first task.</strong> It’s like TDD, but the test doesn’t need to be a permanent fixture in your test suite—it just needs to exist as a clear success criterion.</p>\n<h2>The Path Forward</h2>\n<p><strong>Fast feedback loops have never been more important for meeting this moment with AI coding agents.</strong> The same mechanisms that make human developers productive enable AI agents to complete tasks successfully without close supervision.</p>\n<p>Here’s what software teams should be doing right now:</p>\n<ol>\n<li><strong>Always tell AI agents how to verify their work</strong>. Be explicit: How do they know they’re done? How do they detect regressions? What tests should pass? Which tests are fast and which are slow? How long can they expect tests to take, before they consider it broken? <strong>Without this information, they’re coding blind.</strong></li>\n<li><strong>Optimize your feedback loops aggressively</strong>. Teams still using dynamically typed languages should seriously consider migration. <strong>The type system feedback alone will dramatically improve AI agent productivity.</strong></li>\n<li><strong>Automate your PR feedback</strong>. If you’re leaving the same stylistic comments repeatedly, encode them as linter rules. <strong>AI agents can follow rules perfectly—they just need the rules to exist.</strong></li>\n<li><strong>Invest in faster test suites</strong>. That 30-minute integration test suite? <strong>It’s now a bottleneck for every AI agent iteration.</strong> Speed matters more than ever.</li>\n</ol>\n<p>The teams that thrive in the AI-augmented development era won’t be those with the smartest engineers or the best AI models. <strong>They’ll be the ones with the fastest, most comprehensive feedback loops</strong>. Because when your agents can iterate at machine speed, the only limiting factor is how quickly they can determine that they’re on the right track.</p>\n<p><strong>Fast feedback loops aren’t just a nice-to-have anymore. They’re the foundation that makes AI coding agents actually productive rather than just impressive demos.</strong> And that difference? That’s what separates teams shipping at startup speed from those still wondering why their vibe coding experiments aren’t delivering results.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .solarized-light { background-color: #FDF6E3; }\n  .solarized-light .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(0, 0, 0, 0.05));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(0, 0, 0, 0.2));\n  }\n  \n  /* Solarized Dark */\n  @media (prefers-color-scheme: dark) {\n    .grvsc-mm-t6zo1R { background-color: #002B36; }\n    .grvsc-mm-t6zo1R .grvsc-line-highlighted::before {\n      background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n      box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n    }\n  }\n</style>","frontmatter":{"title":"🤖 AI Coding Agents and the Primacy of Fast Feedback Loops","date":"June 28, 2025","description":"Why fast feedback loops—an evergreen concept in programming—have become the critical enabler for productive AI coding agents."}}},"pageContext":{"slug":"/blog/ai-agents-feedback-loops/","previous":{"fields":{"slug":"/blog/claude-code-seed-stage-startup/","sourceName":"blog"},"frontmatter":{"title":"🤖 How Claude Code Transforms Development Workflows at a Seed-Stage Startup"}},"next":null}},"staticQueryHashes":["2841359383","614056702"],"slicesMap":{}}