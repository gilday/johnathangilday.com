{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/java-nio-files/","result":{"data":{"site":{"siteMetadata":{"author":{"name":"Johnathan Gilday"},"blogTitle":"/ gilday / blog"}},"markdownRemark":{"id":"75b93821-ab8d-5c28-8749-cc812a76afce","excerpt":"If you’re like me, you associate the  package introduced in Java 1.7\nwith nonblocking IO. For years, I ignored the  sub-package,\nbecause I was not working with…","html":"<p>If you’re like me, you associate the <code class=\"language-text\">java.nio</code> package introduced in Java 1.7\nwith nonblocking IO. For years, I ignored the <code class=\"language-text\">java.nio.file</code> sub-package,\nbecause I was not working with the nonblocking IO types in <code class=\"language-text\">java.nio</code>. I wrongly\nassumed that meant I did not need to consider the types in <code class=\"language-text\">java.nio.file</code>. What\nI eventually came to learn is the “n” in <code class=\"language-text\">java.nio</code> <strong>does not</strong> stand for\n<em>nonblocking</em>; rather, it stands for <em>new</em> (according to\n<a href=\"https://jcp.org/en/jsr/detail?id=51\">JSR 51</a>).</p>\n<p>Referring to <code class=\"language-text\">java.nio.file</code>, JSR 51 says it introduces “an improved file system\ninterface”. More than a decade after the release of this improved file system\ninterface, I find that Java developers still feel more comfortable writing code\nthat uses <code class=\"language-text\">java.io.File</code> instead. In this article, we’ll explore some reasons\nwhy it’s time to consider using <code class=\"language-text\">java.nio.file</code> instead of <code class=\"language-text\">java.io.File</code> in\nyour next Java project.</p>\n<h2>Error Handling</h2>\n<p>Consider the following <code class=\"language-text\">java.io.File</code> code for creating a directory:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">var</span> dir <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"my-new-directory\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>file<span class=\"token punctuation\">.</span><span class=\"token function\">mkdir</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// failed to make directory, handle error</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note the error case. The <code class=\"language-text\">mkdir</code> method returns a boolean that indicates whether\nthe directory was created. It’s too easy for developers to forget to check the\nboolean returned by <code class=\"language-text\">mkdir</code> and handle this case.</p>\n<p>Even when developers do remember to check the returned boolean, all they know is\nthat the directory wasn’t created. They can’t know if this is an error they\nshould ignore or not. Was the directory not created, because the directory\nalready exists or because someone ripped the hard drive out? We can’t tell.</p>\n<p>Rather than returning a boolean, throwing an exception is an idiomatic way to do\nerror handling in Java. The <code class=\"language-text\">java.nio.file</code> APIs throw exceptions to communicate\nerrors. Consider the same code using <code class=\"language-text\">java.nio.file</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">var</span> dir <span class=\"token operator\">=</span> <span class=\"token class-name\">Paths</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"my-new-directory\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Files</span><span class=\"token punctuation\">.</span><span class=\"token function\">createDirectory</span><span class=\"token punctuation\">(</span>dir<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">FileAlreadyExistsException</span> ignored<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// something horrible has happened</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here, we can use different exception types to handle cases differently. There’s\nmore information communicated in these exceptions than simply a returned\n<code class=\"language-text\">false</code>.</p>\n<p>This example only considered the “creating a directory” use case, but this\npattern may be found throughout the APIs for working with the file system.\n“Better error handling” is an improvement that any Java program can benefit\nfrom.</p>\n<h2>File System Abstraction</h2>\n<p>The <code class=\"language-text\">java.nio.file</code> package introduces a <code class=\"language-text\">FileSystem</code> abstraction for modeling a\nfile system. Of course, most use cases will only ever use the default\n<code class=\"language-text\">FileSystem</code> (returned by <code class=\"language-text\">FileSystems.getDefault()</code>), but this is a powerful\nconcept that allows for more advanced use cases.</p>\n<p>My favorite use case for this abstraction is leveraging an in-memory file system\nlike <a href=\"https://github.com/google/jimfs\">google/jimfs</a>. This can be particularly\nuseful for speeding up automated tests that perform a lot of file system\noperations with small files, because the in-memory file system is so much faster\nthan a file system on disk.</p>\n<p>Consider this test set-up example that injects an in-memory file system into a\nclass <code class=\"language-text\">MyDocumentManager</code> that performs a lot of file system operations.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyDocumentManagerTest</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">FileSystem</span> fs<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">MyDocumentManager</span> documents<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@Before</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">before</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fs <span class=\"token operator\">=</span> <span class=\"token class-name\">Jimfs</span><span class=\"token punctuation\">.</span><span class=\"token function\">newFileSystem</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Configuration</span><span class=\"token punctuation\">.</span><span class=\"token function\">unix</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// inject in-memory file system into MyDocumentManager for testing</span>\n    documents <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyDocumentManager</span><span class=\"token punctuation\">(</span>fs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token annotation punctuation\">@After</span>\n  <span class=\"token keyword\">void</span> <span class=\"token function\">after</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fs<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Cloud storage is another good use case for this abstraction. Google Cloud’s\n<a href=\"https://cloud.google.com/java/docs/reference/google-cloud-nio/latest/com.google.cloud.storage.contrib.nio\">com.google.cloud.storage.contrib.nio</a>\npackage makes available a Google Cloud Storage backed <code class=\"language-text\">FileSystem</code>. With this\nimplementation, Java programs can access data in Google Cloud Storage with the\nsame APIs they use to access files on disk.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Path</span> path <span class=\"token operator\">=</span> <span class=\"token class-name\">Paths</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">URI</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gs://bucket/lolcat.csv\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> lines <span class=\"token operator\">=</span> <span class=\"token class-name\">Files</span><span class=\"token punctuation\">.</span><span class=\"token function\">readAllLines</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span><span class=\"token constant\">UTF_8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>To benefit most from this abstraction, developers must be mindful not to\ninadvertently couple their code to the default file system. This coupling\nhappens when users call APIs that reference the static global\n<code class=\"language-text\">FileSystems.getDefault()</code>. Typically, this happens inadvertently via other\nstatic accessors like <code class=\"language-text\">Path.of</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyDocumentManager</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> root<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">InputStream</span> is<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> path <span class=\"token operator\">=</span> <span class=\"token class-name\">Path</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ⚠️ Inadvertently couples to default file system</span>\n    <span class=\"token class-name\">Files</span><span class=\"token punctuation\">.</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>is<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Instead, developers should apply good inversion of control practices when\nworking with the file system. That is, prefer to inject a root <code class=\"language-text\">Path</code> or\n<code class=\"language-text\">FileSystem</code> instead of obtaining a reference from a static accessor:</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyDocumentManager</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Path</span> root<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">save</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">InputStream</span> is<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> path <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ resolves relative to injected Path root</span>\n    <span class=\"token class-name\">Files</span><span class=\"token punctuation\">.</span><span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>is<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In the second example, the <code class=\"language-text\">MyDocumentManager</code> type is not coupled to any\nparticular <code class=\"language-text\">FileSystem</code>; rather, it uses whatever <code class=\"language-text\">FileSystem</code> the injected\n<code class=\"language-text\">Path</code> root belongs to.</p>\n<h2>Misc</h2>\n<p>There are a handful of other benefits to the <code class=\"language-text\">java.nio.file</code> APIs that I’ll\nsuccinctly list here:</p>\n<ul>\n<li>Processing directory listings as a <code class=\"language-text\">Stream</code></li>\n<li>Convenience methods for reading files e.g. <code class=\"language-text\">Files.lines(Path)</code>,\n<code class=\"language-text\">newInputStream(Path)</code>, and <code class=\"language-text\">newBufferedReader(Path)</code>.</li>\n<li>Watching directories and files for changes.</li>\n<li>Matching file paths to a pattern (e.g. globbing).</li>\n</ul>\n<p>One day, I’ll find the time to expand these bullets into proper headings of\ntheir own.</p>\n<h2>Conclusion</h2>\n<p>The <code class=\"language-text\">java.nio.file</code> APIs are not new, but they are to many developers accustomed\nto using <code class=\"language-text\">java.io.File</code>. In this article, we explored a handful of reasons why\ndevelopers should prefer to use <code class=\"language-text\">java.nio.file</code> instead of <code class=\"language-text\">java.io.File</code> for\nfile system access on their next Java project.</p>","frontmatter":{"title":"☕️ Reasons to Prefer Java's New I/O for Working With Files","date":"January 16, 2023","description":"When Java introduced the java.nio.file package for working with files (in version 1.7), Java did not deprecate the existing java.io.File type. Is there a reason to prefer one of these seemingly duplicative strategies for working with files? I argue there is.\n"}}},"pageContext":{"slug":"/blog/java-nio-files/","previous":{"fields":{"slug":"/blog/stream-stax/","sourceName":"blog"},"frontmatter":{"title":"☕️ Connecting Java's Streaming API for XML (StAX) with Streams"}},"next":null}},"staticQueryHashes":["2841359383","614056702"],"slicesMap":{}}